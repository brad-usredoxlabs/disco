#!/usr/bin/env node

import path from 'path'
import { fileURLToPath } from 'url'
import { promises as fs } from 'fs'
import YAML from 'yaml'
import { parseFrontMatter } from '../src/records/frontMatter.js'
import { extractRecordData, mergeMetadataAndFormData } from '../src/records/jsonLdFrontmatter.js'
import { buildZodSchema } from '../src/records/zodBuilder.js'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const projectRoot = path.resolve(__dirname, '..')
const EXPORT_DIR = path.join(projectRoot, 'dist', 'ro-crate')

async function main() {
  const bundleName = process.argv[2] || 'computable-lab'
  const bundle = await loadSchemaBundle(bundleName)
  const naming = await readYaml(path.join(projectRoot, 'naming', `${bundleName}.yaml`))
  if (!naming) {
    throw new Error(`Missing naming config for bundle "${bundleName}".`)
  }

  const validators = buildValidators(bundle.recordSchemas)
  const records = []

  for (const [recordType, config] of Object.entries(naming)) {
    const baseDir = config?.baseDir
    if (!baseDir) continue
    const dirPath = path.join(projectRoot, baseDir)
    const files = await collectMarkdownFiles(dirPath)
    for (const filePath of files) {
      const relativePath = path.relative(projectRoot, filePath)
      const record = await loadRecord(filePath, recordType, bundle, validators[recordType])
      if (record) {
        records.push({ ...record, relativePath })
      }
    }
  }

  if (!records.length) {
    throw new Error('No records available to export. Ensure build-index succeeds first.')
  }

  await writeRoCrate(records)
  console.log(`RO-Crate exported to ${EXPORT_DIR}`)
}

async function loadRecord(filePath, defaultType, bundle, validator) {
  const raw = await fs.readFile(filePath, 'utf8')
  if (!raw.trim().startsWith('---')) return null
  const { data, body } = parseFrontMatter(raw)
  if (!data) return null
  const frontMatter = data
  const recordType =
    frontMatter.metadata?.recordType ||
    frontMatter.recordType ||
    frontMatter.type ||
    defaultType
  if (!recordType) return null

  const { metadata, formData } = extractRecordData(recordType, frontMatter, bundle)
  const schemaPayload = mergeMetadataAndFormData(metadata, formData)
  if (validator) {
    const validationInput = stripUnknownFields(schemaPayload, bundle.recordSchemas?.[recordType])
    const result = validator.safeParse(validationInput)
    if (!result.success) {
      console.warn(`[export-rocrate] Skipping ${filePath} due to validation errors:`)
      result.error.issues.forEach((issue) => {
        console.warn(`  - ${issue.path.join('.') || 'root'}: ${issue.message}`)
      })
      return null
    }
  }
  const jsonLdNode = composeJsonLd(metadata, formData)
  return {
    recordType,
    jsonLd: jsonLdNode,
    body
  }
}

function composeJsonLd(metadata, formData) {
  const node = { ...(metadata || {}) }
  if (node.formData) delete node.formData
  Object.entries(formData || {}).forEach(([key, value]) => {
    if (value !== undefined) node[key] = value
  })
  return node
}

async function writeRoCrate(records) {
  await fs.mkdir(EXPORT_DIR, { recursive: true })
  const dataset = buildDatasetEntity(records)
  const graph = [
    dataset,
    ...records.map((record) => buildRecordEntity(record))
  ]
  const roCrate = {
    '@context': 'https://w3id.org/ro/crate/1.1/context',
    '@graph': graph
  }
  await fs.writeFile(path.join(EXPORT_DIR, 'ro-crate-metadata.json'), JSON.stringify(roCrate, null, 2), 'utf8')
  await fs.writeFile(
    path.join(EXPORT_DIR, 'README.txt'),
    'RO-Crate generated by scripts/export-rocrate.mjs. Contents mirror the YAML frontmatter (JSON-LD) for each record.',
    'utf8'
  )
}

function buildDatasetEntity(records) {
  return {
    '@id': './',
    '@type': 'Dataset',
    name: 'DIsCo Pages RO-Crate export',
    description: 'Records exported from DIsCo Pages 2.0',
    hasPart: records.map((record) => record.jsonLd['@id'] || record.jsonLd.id).filter(Boolean)
  }
}

function buildRecordEntity({ recordType, jsonLd }) {
  const entity = {
    '@id': jsonLd['@id'] || jsonLd.id || `${recordType}:${jsonLd.shortSlug || ''}`,
    '@type': jsonLd['@type'] || [`ex:${recordType}`],
    ...jsonLd
  }
  return entity
}

async function loadSchemaBundle(bundleName) {
  const manifestPath = path.join(projectRoot, 'schema', bundleName, 'manifest.yaml')
  const manifest = await readYaml(manifestPath)
  if (!manifest) {
    throw new Error(`Manifest missing for bundle "${bundleName}".`)
  }
  const recordSchemas = await loadYamlMap(manifest.recordSchemas || [], bundleName, 'schema')
  const uiConfigs = await loadYamlMap(manifest.uiConfigs || [], bundleName, 'schema')
  const metadataFields = buildMetadataFieldMap(manifest.metadataFields || {}, recordSchemas)
  return {
    manifest,
    recordSchemas,
    uiConfigs,
    metadataFields
  }
}

async function loadYamlMap(files, bundleName, baseDir) {
  const map = {}
  for (const filename of files) {
    const recordType = deriveRecordType(filename)
    const filePath = path.join(projectRoot, baseDir, bundleName, filename)
    const yaml = await readYaml(filePath)
    if (yaml) {
      map[recordType] = yaml
    }
  }
  return map
}

function deriveRecordType(filename) {
  return filename.replace(/\.schema\.ya?ml$/i, '').replace(/\.ui\.ya?ml$/i, '').replace(/\.ya?ml$/i, '')
}

function buildMetadataFieldMap(config = {}, recordSchemas = {}) {
  const map = {}
  const defaultFields = config.default || []
  Object.keys(recordSchemas).forEach((recordType) => {
    map[recordType] = config[recordType] || defaultFields
  })
  return map
}

async function readYaml(filePath) {
  try {
    const text = await fs.readFile(filePath, 'utf8')
    return YAML.parse(text)
  } catch {
    return null
  }
}

async function collectMarkdownFiles(dir) {
  const files = []
  async function walk(current) {
    let entries
    try {
      entries = await fs.readdir(current, { withFileTypes: true })
    } catch {
      return
    }
    for (const entry of entries) {
      const fullPath = path.join(current, entry.name)
      if (entry.isDirectory()) {
        await walk(fullPath)
      } else if (entry.isFile() && entry.name.toLowerCase().endsWith('.md')) {
        files.push(fullPath)
      }
    }
  }
  await walk(dir)
  return files
}

function buildValidators(recordSchemas) {
  const validators = {}
  const context = { schemas: recordSchemas }
  for (const [recordType, schema] of Object.entries(recordSchemas || {})) {
    if (!schema) continue
    try {
      validators[recordType] = buildZodSchema(schema, context)
    } catch (err) {
      console.warn(`[export-rocrate] Unable to compile validator for ${recordType}: ${err.message}`)
    }
  }
  return validators
}

function stripUnknownFields(payload, schema) {
  if (!payload || typeof payload !== 'object') return payload
  const allowed = new Set(Object.keys(schema?.properties || {}))
  if (!allowed.size) return payload
  const next = {}
  Object.entries(payload).forEach(([key, value]) => {
    if (allowed.has(key)) {
      next[key] = value
    }
  })
  return next
}

main().catch((err) => {
  console.error('[export-rocrate] Failed:', err)
  process.exitCode = 1
})
